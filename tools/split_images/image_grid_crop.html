<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>이미지 격자 자르기 도구</title>
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      background: #1a1a2e;
      color: #eee;
    }
    h1 { font-size: 1.4rem; margin-bottom: 20px; }
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
      margin-bottom: 20px;
      padding: 16px;
      background: #16213e;
      border-radius: 8px;
    }
    .control-group {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    label { font-size: 0.9rem; white-space: nowrap; }
    input[type="number"] {
      width: 70px;
      padding: 6px 8px;
      border: 1px solid #0f3460;
      border-radius: 4px;
      background: #0f3460;
      color: #eee;
      font-size: 14px;
    }
    input[type="file"] {
      padding: 8px;
      background: #0f3460;
      border-radius: 4px;
      color: #eee;
      font-size: 14px;
    }
    button {
      padding: 10px 24px;
      border: none;
      border-radius: 6px;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s;
    }
    .btn-load { background: #e94560; color: white; }
    .btn-load:hover { background: #ff6b6b; }
    .btn-crop { background: #00b894; color: white; }
    .btn-crop:hover { background: #00cec9; }
    .btn-download { background: #0984e3; color: white; margin-left: 8px; }
    .btn-download:hover { background: #74b9ff; }
    .btn-download:disabled { opacity: 0.5; cursor: not-allowed; }
    .btn-split { background: #9b59b6; color: white; margin-left: 8px; }
    .btn-split:hover { background: #8e44ad; }
    .btn-split:disabled { opacity: 0.5; cursor: not-allowed; }
    .preview-area {
      position: relative;
      overflow: auto;
      max-height: 70vh;
      background: #0f0f23;
      border-radius: 8px;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      padding: 20px;
    }
    .canvas-wrapper {
      position: relative;
      display: inline-block;
      cursor: grab;
    }
    .canvas-wrapper.dragging { cursor: grabbing; }
    #mainCanvas { display: block; max-width: 100%; }
    #gridCanvas {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: auto;
      cursor: grab;
    }
    .result-area {
      margin-top: 24px;
      padding: 16px;
      background: #16213e;
      border-radius: 8px;
      display: none;
    }
    .result-area.visible { display: block; }
    .result-area h3 { margin: 0 0 12px 0; font-size: 1rem; }
    .result-area img {
      max-width: 100%;
      border-radius: 6px;
      border: 2px solid #0f3460;
    }
    .help-text {
      font-size: 0.85rem;
      color: #8892b0;
      margin-top: 12px;
      line-height: 1.5;
    }
  </style>
</head>
<body>
  <h1>이미지 격자 자르기 도구</h1>

  <div class="controls">
    <div class="control-group">
      <input type="file" id="fileInput" accept="image/*">
      <button class="btn-load" id="loadBtn">이미지 불러오기</button>
    </div>
    <div class="control-group">
      <label>격자 행:</label>
      <input type="number" id="rows" value="8" min="1" max="20">
    </div>
    <div class="control-group">
      <label>격자 열:</label>
      <input type="number" id="cols" value="8" min="1" max="20">
    </div>
    <div class="control-group">
      <label>격자 가로(px):</label>
      <input type="number" id="gridWidth" min="1" placeholder="가로">
    </div>
    <div class="control-group">
      <label>격자 세로(px):</label>
      <input type="number" id="gridHeight" min="1" placeholder="세로">
    </div>
    <div class="control-group">
      <label>위 자르기(px):</label>
      <input type="number" id="cropTop" value="0" min="0">
    </div>
    <div class="control-group">
      <label>아래 자르기(px):</label>
      <input type="number" id="cropBottom" value="0" min="0">
    </div>
    <div class="control-group">
      <label>왼쪽 자르기(px):</label>
      <input type="number" id="cropLeft" value="0" min="0">
    </div>
    <div class="control-group">
      <label>오른쪽 자르기(px):</label>
      <input type="number" id="cropRight" value="0" min="0">
    </div>
    <div class="control-group">
      <button class="btn-crop" id="cropBtn">자르기</button>
      <button class="btn-download" id="downloadBtn" disabled>저장하기</button>
      <button class="btn-split" id="splitBtn">격자별 개별 파일</button>
    </div>
  </div>

  <div class="preview-area">
    <div class="canvas-wrapper">
      <canvas id="mainCanvas"></canvas>
      <canvas id="gridCanvas"></canvas>
    </div>
  </div>

  <div class="result-area" id="resultArea">
    <h3>자른 결과</h3>
    <img id="resultImage" alt="자른 이미지">
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <p class="help-text">
    사용법: 이미지를 불러온 후 격자 행/열을 지정하세요. 격자는 마우스로 드래그하여 이동할 수 있으며, 숫자 입력으로도 조정 가능합니다. 자르기 버튼을 누르면 격자 밖의 여백이 제거됩니다.
  </p>

  <script>
    const fileInput = document.getElementById('fileInput');
    const loadBtn = document.getElementById('loadBtn');
    const rowsInput = document.getElementById('rows');
    const colsInput = document.getElementById('cols');
    const gridWidthInput = document.getElementById('gridWidth');
    const gridHeightInput = document.getElementById('gridHeight');
    const cropTop = document.getElementById('cropTop');
    const cropBottom = document.getElementById('cropBottom');
    const cropLeft = document.getElementById('cropLeft');
    const cropRight = document.getElementById('cropRight');
    const cropBtn = document.getElementById('cropBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const splitBtn = document.getElementById('splitBtn');
    const mainCanvas = document.getElementById('mainCanvas');
    const gridCanvas = document.getElementById('gridCanvas');
    const canvasWrapper = document.querySelector('.canvas-wrapper');
    const resultArea = document.getElementById('resultArea');
    const resultImage = document.getElementById('resultImage');

    let sourceImage = null;
    let croppedDataUrl = null;
    let isDragging = false;
    let dragStart = { x: 0, y: 0, top: 0, bottom: 0, left: 0, right: 0 };

    loadBtn.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const img = new Image();
      img.onload = () => {
        sourceImage = img;
        setupCanvas();
        drawImageAndGrid();
        downloadBtn.disabled = true;
      };
      img.src = URL.createObjectURL(file);
    });

    function updateGridSizeFromCrop() {
      if (!sourceImage) return;
      const top = parseInt(cropTop.value) || 0;
      const bottom = parseInt(cropBottom.value) || 0;
      const left = parseInt(cropLeft.value) || 0;
      const right = parseInt(cropRight.value) || 0;
      gridWidthInput.value = mainCanvas.width - left - right;
      gridHeightInput.value = mainCanvas.height - top - bottom;
    }

    function updateCropFromGridSize() {
      if (!sourceImage) return;
      const w = parseInt(gridWidthInput.value);
      const h = parseInt(gridHeightInput.value);
      if (!w || !h || w < 1 || h < 1) return;
      const left = parseInt(cropLeft.value) || 0;
      const top = parseInt(cropTop.value) || 0;
      const maxW = mainCanvas.width;
      const maxH = mainCanvas.height;
      cropRight.value = Math.max(0, maxW - left - w);
      cropBottom.value = Math.max(0, maxH - top - h);
    }

    [rowsInput, colsInput, cropTop, cropBottom, cropLeft, cropRight].forEach(el => {
      el.addEventListener('input', () => {
        updateGridSizeFromCrop();
        drawImageAndGrid();
      });
      el.addEventListener('change', () => {
        updateGridSizeFromCrop();
        drawImageAndGrid();
      });
    });

    [gridWidthInput, gridHeightInput].forEach(el => {
      el.addEventListener('input', () => {
        updateCropFromGridSize();
        drawImageAndGrid();
      });
      el.addEventListener('change', () => {
        updateCropFromGridSize();
        drawImageAndGrid();
      });
    });

    function setupCanvas() {
      if (!sourceImage) return;
      mainCanvas.width = sourceImage.width;
      mainCanvas.height = sourceImage.height;
      gridCanvas.width = sourceImage.width;
      gridCanvas.height = sourceImage.height;
      updateGridSizeFromCrop();
    }

    function drawImageAndGrid() {
      if (!sourceImage) return;
      const ctx = mainCanvas.getContext('2d');
      const gCtx = gridCanvas.getContext('2d');
      ctx.clearRect(0, 0, mainCanvas.width, mainCanvas.height);
      gCtx.clearRect(0, 0, gridCanvas.width, gridCanvas.height);
      ctx.drawImage(sourceImage, 0, 0);

      const top = parseInt(cropTop.value) || 0;
      const bottom = parseInt(cropBottom.value) || 0;
      const left = parseInt(cropLeft.value) || 0;
      const right = parseInt(cropRight.value) || 0;
      const rows = parseInt(rowsInput.value) || 1;
      const cols = parseInt(colsInput.value) || 1;

      const contentX = left;
      const contentY = top;
      const contentW = mainCanvas.width - left - right;
      const contentH = mainCanvas.height - top - bottom;

      gCtx.strokeStyle = 'rgba(255, 215, 0, 0.8)';
      gCtx.lineWidth = 1.5;
      gCtx.strokeRect(contentX, contentY, contentW, contentH);

      const cellW = contentW / cols;
      const cellH = contentH / rows;
      for (let r = 1; r < rows; r++) {
        gCtx.beginPath();
        gCtx.moveTo(contentX, contentY + r * cellH);
        gCtx.lineTo(contentX + contentW, contentY + r * cellH);
        gCtx.stroke();
      }
      for (let c = 1; c < cols; c++) {
        gCtx.beginPath();
        gCtx.moveTo(contentX + c * cellW, contentY);
        gCtx.lineTo(contentX + c * cellW, contentY + contentH);
        gCtx.stroke();
      }
    }

    function getCanvasCoords(e) {
      const rect = canvasWrapper.getBoundingClientRect();
      const scaleX = mainCanvas.width / rect.width;
      const scaleY = mainCanvas.height / rect.height;
      return {
        x: (e.clientX - rect.left) * scaleX,
        y: (e.clientY - rect.top) * scaleY
      };
    }

    canvasWrapper.addEventListener('mousedown', (e) => {
      if (!sourceImage) return;
      const { x, y } = getCanvasCoords(e);
      const top = parseInt(cropTop.value) || 0;
      const bottom = parseInt(cropBottom.value) || 0;
      const left = parseInt(cropLeft.value) || 0;
      const right = parseInt(cropRight.value) || 0;
      const contentX = left;
      const contentY = top;
      const contentW = mainCanvas.width - left - right;
      const contentH = mainCanvas.height - top - bottom;
      if (x >= contentX && x <= contentX + contentW && y >= contentY && y <= contentY + contentH) {
        e.preventDefault();
        isDragging = true;
        canvasWrapper.classList.add('dragging');
        dragStart = { x, y, top, bottom, left, right };
      }
    });

    document.addEventListener('mousemove', (e) => {
      if (!isDragging || !sourceImage) return;
      const { x, y } = getCanvasCoords(e);
      const dx = Math.round(x - dragStart.x);
      const dy = Math.round(y - dragStart.y);
      const maxW = mainCanvas.width;
      const maxH = mainCanvas.height;
      let newLeft = dragStart.left + dx;
      let newRight = dragStart.right - dx;
      let newTop = dragStart.top + dy;
      let newBottom = dragStart.bottom - dy;
      newLeft = Math.max(0, Math.min(newLeft, maxW - 1));
      newRight = Math.max(0, Math.min(newRight, maxW - newLeft));
      newTop = Math.max(0, Math.min(newTop, maxH - 1));
      newBottom = Math.max(0, Math.min(newBottom, maxH - newTop));
      cropLeft.value = newLeft;
      cropRight.value = newRight;
      cropTop.value = newTop;
      cropBottom.value = newBottom;
      drawImageAndGrid();
    });

    document.addEventListener('mouseup', () => {
      if (isDragging) {
        isDragging = false;
        canvasWrapper.classList.remove('dragging');
      }
    });

    document.addEventListener('mouseleave', () => {
      if (isDragging) {
        isDragging = false;
        canvasWrapper.classList.remove('dragging');
      }
    });

    cropBtn.addEventListener('click', () => {
      if (!sourceImage) return;
      const top = parseInt(cropTop.value) || 0;
      const bottom = parseInt(cropBottom.value) || 0;
      const left = parseInt(cropLeft.value) || 0;
      const right = parseInt(cropRight.value) || 0;

      const sx = left;
      const sy = top;
      const sw = sourceImage.width - left - right;
      const sh = sourceImage.height - top - bottom;

      if (sw <= 0 || sh <= 0) {
        alert('자를 영역이 올바르지 않습니다. 값을 확인하세요.');
        return;
      }

      const out = document.createElement('canvas');
      out.width = sw;
      out.height = sh;
      const outCtx = out.getContext('2d');
      outCtx.drawImage(sourceImage, sx, sy, sw, sh, 0, 0, sw, sh);

      croppedDataUrl = out.toDataURL('image/png');
      resultImage.src = croppedDataUrl;
      resultArea.classList.add('visible');
      resultImage.scrollIntoView({ behavior: 'smooth' });
      downloadBtn.disabled = false;
    });

    downloadBtn.addEventListener('click', () => {
      if (!croppedDataUrl) return;
      const a = document.createElement('a');
      a.href = croppedDataUrl;
      a.download = 'cropped_image.png';
      a.click();
    });

    splitBtn.addEventListener('click', async () => {
      if (!sourceImage) return;
      const top = parseInt(cropTop.value) || 0;
      const bottom = parseInt(cropBottom.value) || 0;
      const left = parseInt(cropLeft.value) || 0;
      const right = parseInt(cropRight.value) || 0;
      const rows = parseInt(rowsInput.value) || 1;
      const cols = parseInt(colsInput.value) || 1;

      const contentX = left;
      const contentY = top;
      const contentW = sourceImage.width - left - right;
      const contentH = sourceImage.height - top - bottom;
      const cellW = contentW / cols;
      const cellH = contentH / rows;

      if (contentW <= 0 || contentH <= 0 || cellW < 1 || cellH < 1) {
        alert('격자 영역이 올바르지 않습니다. 값을 확인하세요.');
        return;
      }

      splitBtn.disabled = true;
      splitBtn.textContent = '생성 중...';

      try {
        const zip = new JSZip();
        const cellCanvas = document.createElement('canvas');
        cellCanvas.width = Math.floor(cellW);
        cellCanvas.height = Math.floor(cellH);
        const cellCtx = cellCanvas.getContext('2d');

        for (let r = 0; r < rows; r++) {
          for (let c = 0; c < cols; c++) {
            const sx = contentX + c * cellW;
            const sy = contentY + r * cellH;
            cellCtx.clearRect(0, 0, cellCanvas.width, cellCanvas.height);
            cellCtx.drawImage(sourceImage, sx, sy, cellW, cellH, 0, 0, cellCanvas.width, cellCanvas.height);
            const dataUrl = cellCanvas.toDataURL('image/png').split(',')[1];
            zip.file(`cell_${r}_${c}.png`, dataUrl, { base64: true });
          }
        }

        const blob = await zip.generateAsync({ type: 'blob' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'grid_cells.zip';
        a.click();
        URL.revokeObjectURL(a.href);
      } catch (err) {
        alert('파일 생성 중 오류가 발생했습니다: ' + err.message);
      }

      splitBtn.disabled = false;
      splitBtn.textContent = '격자별 개별 파일';
    });

    window.addEventListener('load', () => {
      const defaultPath = 'images/img1.png';
      const img = new Image();
      img.onload = () => {
        sourceImage = img;
        setupCanvas();
        drawImageAndGrid();
      };
      img.onerror = () => {}; // 기본 이미지 없으면 무시
      img.src = defaultPath;
    });
  </script>
</body>
</html>
